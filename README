COMS E6111 Advanced Database Systems - Project 1

a) Group members:

    Di Ruan (dr2763)
    Jie-Gang Kuang (jk3735)



b) Files:

    /--+--README
       +--main.py
       +--Computation.py
       +--Document.py
       +--QueryExpansion.py
       +--Search_engine.py
       +--Xml_parser.py
       +--stopwords.txt
       +--transcript_musk.txt
       +--transcript_gates.txt
       +--transcript_columbia.txt



c) How to run:

    python main.py <bing account key> <precision> <query>
    where:
        * bing account key: the Bing Account Key used for searching
        * precision: a real number between 0 and 1
        * query: a list of words in single quotes


d) Internal design:

    Overall structure:
    Our program is mainly composed of four parts: search, parsing, judgement, and query expansion.

    main.py: The entry point of the program. At the beginning of the routine, the query term list is processed by the
    search engine to form the request to the Bing server. In our setting, the result of the search from the Bing server
    will contain top-10 relevant web sites and be of XML format. The XML object is then parsed to get the information
    for users to decide whether each result is indeed relevant or not. After the judgement process is done, the program
    terminates if the desired relevance of the result is met or there is totally no relevant result. However, when there
    are relevant results but the relevance requirement is not met, the routine must be redone to get more relevant
    results. For the next routine, we pass the entire judgement result including the content of search results to the
    query expansion module which can compute the best fit words for the next round. The routine is then repeated until
    the relevance requirement is met.

    Computation.py: Contain some vector calculation methods that are used in the query expansion calculation

    Search_engine.py: Format the query url that is used by Bing API and get the result back

    Xml_parser.py: Parse the XML result returned by Bing so that we can retrieve the part of information
    that we are interested in

    QueryExpansion.py: Contain the query expansion algorithm which will be explained in detail in part(e)

    Document.py: Define a class for representing each document returned by the Bing Search API




e) Details of query modification:

The query modification algorithm is composed of the following parts:
1. remove the symbols and stop-words
        As a part of the

2. Give different weights to title and description
        Based on our survey of the research papers, we find that we need to assign different weights to the terms in
    different part. For example, if a term is in the title, we should assign more weight to it. Therefore, after numbers
    of experiments, we have chosen to assign 1.2 to the terms in the title while 1 to the others.

3. calculate the normalized term frequency for each document
        We take the normalized term frequency instead of the original term frequency. This is calculated by dividing
    the length of the document.

4. tf-idf
        In order to

5. Rocchio algorithm
        The key part of our query modification algorithm is Rocchio algorithm, which is also the most popular algorithm
    in query expansion.



f) Bing Search Account Key: 6SBqV1l4XaDnfx+w4rPVqyEgtNJqvUJu50wXdg5njhk




g) Results

Comparison between our results and that of the reference program




h) Additional information:

1. Character encoding:
        When we construct the inverted files, one of the nasty problems we encounter is character encoding. Some results
    in XML are returned containing unicode encoding characters and some non-ascii characters, which introduce some
    unexpected results. Our approach is simply replacing each of them with a whitespace. In our observation, because the
    most information lies in alphanumeric characters which are most of the time ascii-encoded, even if we replace the
    non-ascii characters with whitespaces, the important information is still preserved.

2. Order of the query terms
        In our implementation, we do not focus on phrases but only treat words as terms. One of the reasons is that to
    distinguish phrases from words, we need statically sustainable data to support the decisions during processing.
    However, the information in the titles, the urls, and the descriptions are far from enough to establish the reliable
    assistance to the computation.

        What we guaranteed in our method is that the order of augmented terms follows the scores computed with Rocchio's
    algorithm. Sometimes it could be non-optimum. For example, after searching with 'Big Apple' and judge for New York,
    the added query terms could be "Big Apple york new". Granted, the result would be the best with "Big Apple new york",
    but when the general algorithm is applied with such statically deficient data, the result could sometimes be worse.
    Rather than occasionally diverging from the desired direction, we decide to use the guaranteed method to augment the
    query.



i) Reference

[1] A Survey of Automatic Query Expansion in Information Retrieval, CLAUDIO CARPINETO and GIOVANNI ROMANO,
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.307.8469&rep=rep1&type=pdf

[2] RELEVANCE FEEDBACK AND OTHER QUERY MODIFICATION TECHNIQUES, Donna Harman,
http://orion.lcg.ufrj.br/Dr.Dobbs/books/book5/chap11.htm
